#+PROPERTY: header-args :tangle yes

* Init
** OS helper macros
Macros for platform-specific code

#+BEGIN_SRC emacs-lisp
(defmacro ms-windows-p ()
  (eq system-type 'windows-nt))

(defmacro cygwin-p ()
  (eq system-type 'cygwin))

(defmacro osx-p ()
  (eq system-type 'darwin))

(defmacro when-windows (&rest body)
  `(if (ms-windows-p) (progn ,@body)))

(defmacro when-cygwin (&rest body)
  `(if (cygwin-p) (progn ,@body)))

(defmacro when-osx (&rest body)
  `(if (osx-p) (progn ,@body)))

(defmacro unless-osx (&rest body)
  `(if (osx-p) nil ,@body))

(defmacro unless-windows (&rest body)
  `(if (ms-windows-p) nil ,@body))
#+END_SRC

** Enable lexical binding
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC
** Garbage collection
We're going to increase the gc-cons-threshold to a very high number to decrease the load and compile time.
We'll lower this value significantly after initialization has completed. We don't want to keep this value
too high or it will result in long GC pauses during normal usage.

#+BEGIN_SRC emacs-lisp :tangle yes
(eval-and-compile
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6))
#+END_SRC

** Byte compile warnings
Disable certain byte compiler warnings to cut down on the noise. This is a personal choice and can be removed
if you would like to see any and all byte compiler warnings.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+END_SRC

** Some basic variables

#+BEGIN_SRC emacs-lisp :tangle yes
(prefer-coding-system 'utf-8)

(setq-default tab-width 4
	      indent-tabs-mode nil)

(fset 'yes-or-no-p 'y-or-n-p)
(setq create-lockfiles nil)
#+END_SRC
** Disable custom settings
Don't add customised settings to init.el

#+BEGIN_SRC emacs-lisp
(setq custom-file (make-temp-file "emacs-custom"))
#+END_SRC
** Fill column
#+BEGIN_SRC emacs-lisp :tangle yes
(defun sanityinc/maybe-adjust-visual-fill-column ()
  "Readjust visual fill column when the global font size is modified.
This is helpful for writeroom-mode, in particular."
  ;; TODO: submit as patch
  (if visual-fill-column-mode
      (add-hook 'after-setting-font-hook 'visual-fill-column--adjust-window nil t)
    (remove-hook 'after-setting-font-hook 'visual-fill-column--adjust-window t)))

(add-hook 'visual-fill-column-mode-hook
          'sanityinc/maybe-adjust-visual-fill-column)
#+END_SRC
** Keep history for recently accessed files

#+BEGIN_SRC emacs-lisp :tangle yes
(recentf-mode 1)
(setq-default
 recentf-max-saved-items 1000
 recentf-exclude '("/tmp/" "/ssh:"))

(add-to-list 'recentf-exclude (format "%s/.*" (expand-file-name "elpa" user-emacs-directory)))
#+END_SRC

** Ido
"Interactively DO things"

#+BEGIN_SRC emacs-lisp :tangle yes
(setq ido-enable-flex-matching t)
(setq ido-everywhere t)

;; Open buffers in the current window
;; (default is to switch to a window which has it open)
(setq ido-default-buffer-method 'selected-window)
(setq ido-default-file-method 'selected-window)

;; Use recentf and ido together
;; http://www.reddit.com/r/emacs/comments/21a4p9/use_recentf_and_ido_together/cgbprem
(setq ido-use-virtual-buffers t)

(defun kwarks/ido-jump-home ()
  (interactive)
  (ido-set-current-directory "~/")
  (setq ido-exit 'refresh)
  (exit-minibuffer))

(defun kwarks/ido-setup-hook ()
  (define-key ido-file-dir-completion-map "~" 'kwarks/ido-jump-home)
  (define-key ido-completion-map [up] 'previous-history-element)
  (define-key ido-completion-map [down] 'next-history-element))

(add-hook 'ido-setup-hook 'kwarks/ido-setup-hook)
(ido-mode 1)
#+END_SRC
** Midnight mode
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'midnight)
(midnight-mode)
#+END_SRC
** Encryption
#+BEGIN_SRC emacs-lisp :tangle yes
(unless-windows
 (require 'epa-file)
 (custom-set-variables '(epg-gpg-program  "/usr/local/bin/gpg"))
 (epa-file-enable))
#+END_SRC

** Backups

#+BEGIN_SRC emacs-lisp :tangle yes
(setq
 backup-by-copying t
 backup-directory-alist `(("." . ,(expand-file-name "backups" user-emacs-directory)))
 delete-old-versions t
 kept-new-versions 16
 kept-old-versions 2
 version-control t)
#+END_SRC

** Sessions
#+BEGIN_SRC emacs-lisp :tangle yes
(setq desktop-path (list user-emacs-directory)
      desktop-auto-save-timeout 600)

(desktop-save-mode 1)

(let ((default (eval (car (get 'desktop-files-not-to-save 'standard-value)))))
  (setq desktop-files-not-to-save
        (eval
         `(rx (or (regexp ,default)
                  (and (or ".plstore"
                           ".desktop"
                           ;; Don't save .gpg files. Restoring those files
                           ;; in emacsclient causes a problem as the
                           ;; password prompt appears before the frame is
                           ;; loaded.
                           ".gpg"
                           ;; FIXME
                           ;; If backup files with names like
                           ;; "file.sv.1.bkp" are saved to the desktop file,
                           ;; emacsclient crashes at launch Need to debug
                           ;; why that's the case. But for now, simply not
                           ;; saving the .bkp files to the desktop file
                           ;; works -- Fri Jun 19 16:45:50 EDT 2015
                           ".bkp"
                           ;; I do not typically plan to re-open the .el.gz
                           ;; files opened in my previous sessions.
                           ".el.gz"
                           "TAGS")
                       line-end))))))

(setq desktop-globals-to-save
      (append '((comint-input-ring        . 50)
                (compile-history          . 30)
                desktop-missing-file-warning
                (dired-regexp-history     . 20)
                (extended-command-history . 30)
                (face-name-history        . 20)
                (file-name-history        . 100)
                (grep-find-history        . 30)
                (grep-history             . 30)
                (ido-buffer-history       . 100)
                (ido-last-directory-list  . 100)
                (ido-work-directory-list  . 100)
                (ido-work-file-list       . 100)
                (magit-read-rev-history   . 50)
                (minibuffer-history       . 50)
                (org-clock-history        . 50)
                (org-refile-history       . 50)
                (org-tags-history         . 50)
                (query-replace-history    . 60)
                (read-expression-history  . 60)
                (regexp-history           . 60)
                (regexp-search-ring       . 20)
                register-alist
                (search-ring              . 20)
                (shell-command-history    . 50)
                tags-file-name
                tags-table-list)))

(setq-default history-length 1000)
(savehist-mode t)

#+END_SRC
** Calendar
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'calendar)
(require 'holidays)

(setq calendar-mark-holidays-flag t)

;; holiday settings for Toronto
(setq calendar-latitude [43 39 north])
(setq calendar-longitude [79 22 west])
(setq calendar-location-name "Toronto, CA")

(setq calendar-christian-all-holidays-flag nil)

;; remove non-relevant holidays
(setq holiday-general-holidays nil)
(setq holiday-hebrew-holidays nil)
(setq holiday-islamic-holidays nil)
(setq holiday-oriental-holidays nil)
(setq holiday-bahai-holidays nil)

(setq holiday-canadian-statutory-holidays
      '((holiday-fixed 01 01 "New Year's Day")
        (holiday-easter-etc -2 "Good friday")
        (holiday-fixed 07 01 "Canada Day")
        (holiday-float 10 1 2 "Thanksgiving") ; Second monday of october
        (holiday-fixed 11 11 "Remembrance day")
        (holiday-fixed 12 25 "Christmas")
        (holiday-fixed 12 26 "Boxing Day")
        (holiday-float 05 1 -1 "Victoria day" 24)  ;Monday before May 24
        (holiday-float 08 1 1 "Civic Public Holiday") ; First monday of August
        (holiday-float 09 1 1 "Labour day") ; First monday in september
        ))

(setq holiday-local-holidays
      '((holiday-fixed 02 14 "Valentine's Day")
        (holiday-float 02 1 3 "Family day") ;Third monday in february
        (holiday-fixed 04 01 "April Fools' Day")
        (holiday-float 5 0 2 "Mother's Day")
        (holiday-float 6 0 3 "Father's Day")
        (holiday-fixed 11 11 "Remembrance day")
        (holiday-advent 0 "Advent")
        (holiday-easter-etc 0 "Easter Sunday")
        (holiday-easter-etc 39 "Ascension Day")
        (holiday-easter-etc 49 "Pentecost (Whitsunday)")
        (holiday-fixed 10 31 "Halloween")
        ))

;; The above settings won't be used because calendar-holidays has already been
;; generated; it has to be re-filled.
(setq calendar-holidays
      (append
       holiday-canadian-statutory-holidays
       holiday-local-holidays
       holiday-solar-holidays))

(defun insert-date (&optional days)
  (interactive "p*")
  (insert
   (calendar-date-string
    (calendar-gregorian-from-absolute
     (+ (calendar-absolute-from-gregorian (calendar-current-date))
        days)))))
#+END_SRC

** Highlight matching parens
#+BEGIN_SRC emacs-lisp :tangle yes
(show-paren-mode 1)
#+END_SRC
** Use xwidget webkit if possible
#+BEGIN_SRC emacs-lisp :tangle yes
(if (featurep 'xwidget-internal)
    (setq browse-url-browser-function 'xwidget-webkit-browse-url))
#+END_SRC

** Platform-specific
Shell initialization for Windows

#+BEGIN_SRC emacs-lisp
(defun init-bash (bash-executable)
  (setq explicit-shell-file-name bash-executable)
  (setq shell-file-name "bash")
  (setq explicit-bash-args '("--noediting" "--login" "-i"))
  (setenv "SHELL" shell-file-name)
  (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m))

(when-windows
 (let ((git-bash "C:/Program Files/Git/bin/sh.exe"))
   (when (file-readable-p git-bash)
     (message "Setting up git bash")
     (init-bash git-bash))))

(when-cygwin
 (let ((cygwin-bin "c:/opt/cygwin64/bin"))
   (when (file-readable-p cygwin-bin)
     (message "Setting up cygwin")
     
     (setq exec-path (cons cygwin-bin exec-path))
     (setenv "PATH" (concat cygwin-bin ";" (getenv "PATH")))
     (init-bash "bash"))))
#+END_SRC

* ELisp Extensions
** Copy Org link
#+BEGIN_SRC emacs-lisp
(defun org-copy-link ()
  "Extract the link location at point and put it on the killring."
  (interactive)
  (when (org-in-regexp org-bracket-link-regexp 1)
    (kill-new (org-link-unescape (org-match-string-no-properties 1)))))
#+END_SRC

** Toggle delete-other-window command
Taken from zygospore, changed window restore behavior.

#+BEGIN_SRC emacs-lisp
(defun kwarks/toggle-delete-other-windows ()
  "Toggle \\[delete-other-window] command.
If the current frame has several windows, it will act as `delete-other-windows'.
If the current frame has one window,
it will restore the window configuration to prior to full-framing."
  (interactive)
  (let ((window-state-register-name "kwarks/last-window-state"))
    (cond
     ((equal (selected-window) (next-window))
      (let ((cb (current-buffer)))
        (jump-to-register window-state-register-name)
        (switch-to-buffer cb)))
     (t
      (window-configuration-to-register window-state-register-name)
      (delete-other-windows)))))

(global-set-key (kbd "C-x 1") 'kwarks/toggle-delete-other-windows)
#+END_SRC

** Insert horizontal divider line

#+BEGIN_SRC emacs-lisp :tangle yes
(defun insert-divider ()
  "Insert horizontal line, i.e. FORM FEED (FF)."
  (interactive)
  (insert #x0C))
#+END_SRC

** Remove leading and tailing spaces.

#+BEGIN_SRC emacs-lisp
(defun trim (str)
  "Remove leading and tailing whitespace from STR."
  (replace-regexp-in-string (rx (or (: bos (* (any " \t\n")))
                                    (: (* (any " \t\n")) eos)))
                            ""
                            str))
#+END_SRC

** Check if string is empty

#+BEGIN_SRC emacs-lisp
(defun empty-string-p (string)
  "Return true if the STRING is empty or nil.  Expects string."
  (or (null string)
      (zerop (length (trim string)))))
#+END_SRC

** Execute shell command in an active shell session

#+BEGIN_SRC emacs-lisp
(defun run-shell-command (cmd)
  (let ((shell-process (get-buffer-process "*shell*")))
    (cond ((not (null shell-process))
           (process-send-string "shell" (concat cmd "\n"))))))
#+END_SRC

** Proxy functions

#+BEGIN_SRC emacs-lisp
(defun kwarks/set-proxy (proxy-host)
  (setq url-proxy-services
        `(("no_proxy" . "^\\(localhost\\|10.*\\)")
          ("http" . ,proxy-host)
          ("https" . ,proxy-host)))
  (setenv "http_proxy" (concat "http://" proxy-host))
  (setenv "https_proxy" (concat "http://" proxy-host))
  (setenv "HTTP_PROXY" (concat "http://" proxy-host))
  (setenv "HTTPS_PROXY" (concat "http://" proxy-host))
  (run-shell-command (concat "export http_proxy=http://" proxy-host))
  (run-shell-command (concat "export https_proxy=http://" proxy-host))
  (run-shell-command (concat "export HTTP_PROXY=http://" proxy-host))
  (run-shell-command (concat "export HTTPS_PROXY=http://" proxy-host)))

(defun proxy-on ()
  "Set proxy."
  (interactive)
  (let ((proxy-host
         (read-string "proxy host: "
                      (if (bound-and-true-p *proxy-host*) *proxy-host* ""))))
    (unless (empty-string-p proxy-host)
      (kwarks/set-proxy proxy-host)
      (message "proxy is set to %s" proxy-host))))

(defun proxy-off ()
  "Unset proxy."
  (interactive)
  (setq url-proxy-services ())
  (setenv "http_proxy" "")
  (setenv "https_proxy" "")
  (setenv "HTTP_PROXY" "")
  (setenv "HTTPS_PROXY" "")
  (run-shell-command "unset http_proxy")
  (run-shell-command "unset https_proxy")
  (run-shell-command "unset HTTP_PROXY")
  (run-shell-command "unset HTTPS_PROXY")
  (message "proxy is off"))
#+END_SRC

** Custom session management

#+BEGIN_SRC emacs-lisp
(defun saved-session ()
  (file-exists-p (concat desktop-dirname "/" desktop-base-file-name)))

;; use session-save to save the desktop manually
(defun session-save ()
  "Save an Emacs session."
  (interactive)
  (if (saved-session)
      (if (y-or-n-p "Overwrite existing desktop? ")
          (desktop-save-in-desktop-dir)
        (message "Session not saved."))
    (desktop-save-in-desktop-dir)))

;; use session-restore to restore the desktop manually
(defun session-restore ()
  "Restore a saved Emacs session."
  (interactive)
  (if (saved-session)
      (desktop-read)
    (message "No desktop found.")))
#+END_SRC

** Clear shell buffer

#+BEGIN_SRC emacs-lisp
(defun clear-shell ()
  "Cleans shell buffer."
  (interactive)
  (let ((comint-buffer-maximum-size 0))
    (comint-truncate-buffer)))
#+END_SRC

** XML pretty print

#+BEGIN_SRC emacs-lisp
(defun xml-pretty-print-region (begin end)
  "Pretty format XML markup in region from BEGIN to END.
You need to have 'nxml-mode'
http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do this.
The function inserts linebreaks to separate tags that have nothing
but whitespace between them.
It then indents the markup by using nxml's indentation rules."
  (interactive "r")
  (save-excursion
    (nxml-mode)
    (goto-char begin)
    (while (search-forward-regexp "\>[ \\t]*\<" nil t)
      (backward-char) (insert "\n") (setq end (1+ end)))
    (indent-region begin end))
  (message "Ah, much better!"))
#+END_SRC

** Hide ^M symbols
#+BEGIN_SRC emacs-lisp
(defun hide-dos-eol ()
  "Do not show ^M in files containing mixed UNIX and DOS line endings."
  (interactive)
  (setq buffer-display-table (make-display-table))
  (aset buffer-display-table ?\^M []))
#+END_SRC

** Edit current file as root

#+BEGIN_SRC emacs-lisp
(defun sudo-edit (&optional arg)
  "Reopens current buffer or ARG as root."
  (interactive "p")
  (if (or arg (not buffer-file-name))
      (find-file (concat "/sudo:root@localhost:" (ido-read-file-name "File: ")))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
#+END_SRC

** Hash-pass for emacs (http://hashapass.com/)

#+BEGIN_SRC emacs-lisp
(defvar hash-pass-password-wait-time "30 sec"
  "The default period to wait before erasing the password from the clipboard.
Must be compatible with `run-at-time'.")

(defvar hash-pass-system-clipboard-only nil
  "If T hash-pass will not put generated password to Emacs kill ring.")

(defun string->clipboard (string)
  "Copy STRING to system clipboard."
  (if hash-pass-system-clipboard-only
      (funcall interprogram-cut-function string)
    (kill-new string)))

(defun hash-pass ()
  "Generate strong password based on parameter and master password."
  (interactive)
  (let ((param (read-string "parameter: "))
        (password (read-passwd "master password: ")))
    (string->clipboard (trim
                        (shell-command-to-string
                         (format "echo -n %s | openssl dgst -sha1 -binary -hmac %s | openssl enc -base64 | cut -c 1-8" param password))))

    (run-at-time hash-pass-password-wait-time nil (lambda () (string->clipboard "")))
    (message "Generated hash has been copied to clipboard")))
#+END_SRC

** Number to string convertion

Port of common lisp (format nil "~r" 1234) and (format nil "~:r" 1234) functions:

#+BEGIN_EXAMPLE
(number-to-english-cardinal 1234) ==> "one thousand two hundred thirty-four"
(number-to-english-ordinal 1234) ==> "one thousand two hundred thirty-fourth"
#+END_EXAMPLE

see https://github.com/sbcl/sbcl/blob/e95100470561cfda5a2f8efd70274509d340686a/src/code/target-format.lisp

#+BEGIN_SRC emacs-lisp
(defvar *cardinal-ones*
  (vector nil "one" "two" "three" "four" "five" "six" "seven" "eight" "nine"))

(defvar *cardinal-tens*
  (vector nil nil "twenty" "thirty" "forty"
          "fifty" "sixty" "seventy" "eighty" "ninety"))

(defvar *cardinal-teens*
  (vector "ten" "eleven" "twelve" "thirteen" "fourteen"
          "fifteen" "sixteen" "seventeen" "eighteen" "nineteen"))

(defvar *cardinal-periods*
  (vector "" " thousand" " million" " billion" " trillion" " quadrillion"
          " quintillion" " sextillion" " septillion" " octillion" " nonillion"
          " decillion" " undecillion" " duodecillion" " tredecillion"
          " quattuordecillion" " quindecillion" " sexdecillion" " septendecillion"
          " octodecillion" " novemdecillion" " vigintillion"))

(defvar *ordinal-ones*
  (vector nil "first" "second" "third" "fourth"
          "fifth" "sixth" "seventh" "eighth" "ninth"))

(defvar *ordinal-tens*
  (vector nil "tenth" "twentieth" "thirtieth" "fortieth"
          "fiftieth" "sixtieth" "seventieth" "eightieth" "ninetieth"))

(defun number-to-english-small-cardinal (n)
  (let ((result "")
        (hundreds (truncate n 100))
        (rem (% n 100)))
    (when (plusp hundreds)
      (setq result (concat result
                           (elt *cardinal-ones* hundreds)
                           " hundred"))
      (when (plusp rem)
        (setq result (concat result " "))))
    (when (plusp rem)
      (let ((tens (truncate rem 10))
            (ones (% rem 10)))
        (cond ((< 1 tens)
               (setq result (concat result (elt *cardinal-tens* tens)))
               (when (plusp ones)
                 (setq result (concat result
                                      "-"
                                      (elt *cardinal-ones* ones)))))
              ((= tens 1)
               (setq result (concat result (elt *cardinal-teens* ones))))
              ((plusp ones)
               (setq result (concat result (elt *cardinal-ones* ones)))))))
    result))

;; (number-to-english-small-cardinal 100)

(defun number-to-english-cardinal-aux (n period err)
  (let ((result "")
        (beyond (truncate n 1000))
        (here (% n 1000)))
    (unless (<= period 21)
      (error "Number too large to print in English: %d" err))
    (unless (zerop beyond)
      (setq result (concat result
                           (number-to-english-cardinal-aux beyond (1+ period) err))))
    (unless (zerop here)
      (unless (zerop beyond)
        (setq result (concat result " ")))
      (setq result (concat result
                           (number-to-english-small-cardinal here)
                           (elt *cardinal-periods* period))))
    result))

;; (number-to-english-cardinal-aux 1000 0 1000)

(defun number-to-english-cardinal (n)
  "Return number N as a human readable english cardinal number."
  (interactive "nNumber? ")
  (let ((result ""))
    (cond ((minusp n)
           (setq result (concat result
                                "negative "
                                (number-to-english-cardinal-aux (- n) 0 n))))
          ((zerop n)
           (setq result "zero"))
          (t
           (setq result (number-to-english-cardinal-aux n 0 n))))
    (when (called-interactively-p 'any)
      (print result))
    result))

;; (number-to-english-cardinal 10000432320000123)

(defun number-to-english-ordinal (n)
  "Return number N as a human readable english ordinal number."
  (interactive "nNumber? ")
  (let ((result ""))
    (when (minusp n)
      (setq result "negative "))
    (let ((number (abs n)))
      (let ((top (truncate number 100))
            (bot (% number 100)))
        (unless (zerop top)
          (setq result (concat result (number-to-english-cardinal (- number bot)))))
        (when (and (plusp top) (plusp bot))
          (setq result (concat result " ")))
        (let ((tens (truncate bot 10))
              (ones (% bot 10)))
          (cond ((= bot 12)
                 (setq result (concat result "twelfth")))
                ((= tens 1)
                 (setq result (concat result
                                      (elt *cardinal-teens* ones)
                                      "th")))
                ((and (zerop tens) (plusp ones))
                 (setq result (concat result (elt *ordinal-ones* ones))))
                ((and (zerop ones)(plusp tens))
                 (setq result (concat result (elt *ordinal-tens* tens))))
                ((plusp bot)
                 (setq result (concat result
                                      (elt *cardinal-tens* tens)
                                      "-"
                                      (elt *ordinal-ones* ones))))
                ((plusp number)
                 (setq result (concat result "th")))
                (t
                 (setq result (concat result "zeroth")))))))
    (when (called-interactively-p 'any)
      (print result))
    result))

;; (osx-say (number-to-english-ordinal 12345))
;; (number-to-english-ordinal 12345)
#+END_SRC

** Lock screen

#+BEGIN_SRC emacs-lisp
(when-osx
  (defun osx-lock-screen ()
    "Start screensaver on OSX."
    (interactive)
    (start-process
     "screensaver" nil
     "open" "-a" "/System/Library/CoreServices/ScreenSaverEngine.app/Contents/MacOS/ScreenSaverEngine")))
#+END_SRC
** Speak text

#+BEGIN_SRC emacs-lisp
(when-osx
  (defun osx-say (phrase)
    "Speak PHRASE."
    (interactive "MSay what? ")
    (start-process "say" nil "say" phrase)))
#+END_SRC

** Canada Post parcel status
#+BEGIN_SRC emacs-lisp
(defun kwarks/canadapost-status (tracking-number)
  "Check parcel location and status from Canada Post"
  (interactive "MTracking number: ")
  (require 'json)
  (with-temp-buffer
    (url-insert-file-contents
     (format "https://www.canadapost.ca/trackweb/rs/track/json/package?pins=%s" tracking-number))
    (let* ((json-object-type 'hash-table)
           (json-array-type 'list)
           (json-key-type 'string)
           (json (car (json-read)))
           (event (gethash "latestEvent" json)))
      (if event
          (let ((datetime (gethash "datetime" event))
                (location (gethash "locationAddr" event)))
            (message (format "[%s %s %s, %s] %s"
                             (gethash "date" datetime)
                             (gethash "time" datetime)
                             (capitalize (gethash "city" location))
                             (capitalize (gethash "countryNmEn" location))
                             (gethash "descEn" event))))
        (message (gethash "descEn" (gethash "error" json)))))))
#+END_SRC
** Transparency
#+BEGIN_SRC emacs-lisp
(defun transparency-fn(step)
  (lambda ()
    (interactive)
    (unless (display-graphic-p nil)
      (error "Cannot adjust opacity of this frame"))

    (let* ((alpha (if (consp (frame-parameter nil 'alpha))
                      (car (frame-parameter nil 'alpha))
                    100))
           (new-alpha (min 100 (max frame-alpha-lower-limit (+ step alpha)))))
      (set-frame-parameter nil 'alpha `(,new-alpha ,new-alpha)))))

(global-set-key (kbd "M-C-9") (transparency-fn 5))
(global-set-key (kbd "M-C-8") (transparency-fn -5))
(global-set-key (kbd "M-C-0") '(lambda() (interactive) (modify-frame-parameters nil `((alpha . 100)))))
#+END_SRC

** Custom scrolling
#+BEGIN_SRC emacs-lisp
(defun kwarks/next-line ()
  (interactive)
  (next-line)
  (scroll-up-line))

(defun kwarks/previous-line ()
  (interactive)
  (previous-line)
  (scroll-down-line))

(global-set-key [M-down] 'kwarks/next-line)
(global-set-key [M-up] 'kwarks/previous-line)
#+END_SRC
** Show decrypted org entry
org-decrypt-entry modifies org file by replacing encrypted content.
This function decrypts and displays org-mode encrypted entry in a separate read-only buffer.

#+BEGIN_SRC emacs-lisp
(defun kwarks/org-display-decrypted-entry ()
  "Display decrypted content of the current headline in a new read-only buffer."
  (interactive)
  (require 'epg)
  (unless (org-before-first-heading-p)
    (org-with-wide-buffer
     (org-back-to-heading t)
     (let ((heading-point (point))
	   (heading-was-invisible-p
	    (save-excursion
	      (outline-end-of-heading)
	      (org-invisible-p))))
       (org-end-of-meta-data)
       (when (looking-at "-----BEGIN PGP MESSAGE-----")
	 (setq-local epg-context (epg-make-context nil t t))
	 (let* ((end (save-excursion
		       (search-forward "-----END PGP MESSAGE-----")
		       (forward-line)
		       (point)))
		(encrypted-text (buffer-substring-no-properties (point) end))
		(decrypted-text
		 (decode-coding-string
		  (epg-decrypt-string
		   epg-context
		   encrypted-text)
		  'utf-8)))
	   (let* ((entry-name (elt (org-heading-components) 4))
		  (buf-name (concat "*decrypted: " entry-name  "*"))
		  (buf (get-buffer-create buf-name)))
	     (with-current-buffer buf
	       (read-only-mode -1)
	       (erase-buffer)
	       (insert decrypted-text)
	       (read-only-mode)
	       (org-mode)
	       (pop-to-buffer buf)))
	   nil))))))
#+END_SRC
** Toggle image display
#+BEGIN_SRC emacs-lisp
(defvar-local endless/display-images t)

(defun endless/toggle-image-display ()
  "Toggle images display on current buffer."
  (interactive)
  (setq endless/display-images
        (null endless/display-images))
  (endless/backup-display-property endless/display-images))

(defun endless/backup-display-property (invert &optional object)
  "Move the 'display property at POS to 'display-backup.
Only applies if display property is an image.
If INVERT is non-nil, move from 'display-backup to 'display
instead.
Optional OBJECT specifies the string or buffer. Nil means current
buffer."
  (let* ((inhibit-read-only t)
         (from (if invert 'display-backup 'display))
         (to (if invert 'display 'display-backup))
         (pos (point-min))
         left prop)
    (while (and pos (/= pos (point-max)))
      (if (get-text-property pos from object)
          (setq left pos)
        (setq left (next-single-property-change pos from object)))
      (if (or (null left) (= left (point-max)))
          (setq pos nil)
        (setq prop (get-text-property left from object))
        (setq pos (or (next-single-property-change left from object)
                      (point-max)))
        (when (eq (car prop) 'image)
          (add-text-properties left pos (list from nil to prop) object))))))
#+END_SRC

** Server shutdown
#+begin_src emacs-lisp
(defun server-shutdown ()
  "Save buffers, Quit, and Shutdown (kill) server"
  (interactive)
  (save-some-buffers)
  (kill-emacs))
#+end_src
* Package Management
Initialize use-package. 

Use /:init/ for code that still has meaning if the package is not loaded. Primarily, this is code that you'd like in place even if loading is deferred until a later time. 

Use /:config/ for code that has meaning after the package is loaded.

** Package Settings
We're going to set the =load-path= ourselves and avoid calling =(package-initilize)= (for
performance reasons) so we need to set =package--init-file-ensured= to true to tell =package.el=
to not automatically call it on our behalf. Additionally we're setting
=package-enable-at-startup= to nil so that packages will not automatically be loaded for us since
=use-package= will be handling that.

#+BEGIN_SRC emacs-lisp :tangle yes
  (eval-and-compile
    (setq load-prefer-newer t
          package-user-dir "~/.emacs.d/elpa"
          package--init-file-ensured t
          package-enable-at-startup nil)

    (unless (file-directory-p package-user-dir)
      (make-directory package-user-dir t)))
#+END_SRC

** Use-Package Settings
Tell =use-package= to always defer loading packages unless explicitly told otherwise. This speeds up
initialization significantly as many packages are only loaded later when they are explicitly used.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq use-package-always-defer t
        use-package-verbose t)
#+END_SRC

** Manually Set Load Path
We're going to set the load path ourselves so that we don't have to call =package-initialize= at
runtime and incur a large performance hit. This load-path will actually be faster than the one
created by =package-initialize= because it appends the elpa packages to the end of the load path.
Otherwise any time a builtin package was required it would have to search all of third party paths
first.

#+BEGIN_SRC emacs-lisp :tangle yes
  (eval-and-compile
    (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t))))
#+END_SRC

** Initialize Package Management
Next we are going to require =package.el= and add our additional package archives, 'melpa' and 'org'.
Afterwards we need to initialize our packages and then ensure that =use-package= is installed, which
we promptly install if it's missing. Finally we load =use-package= and tell it to always install any
missing packages.

Note that this entire block is wrapped in =eval-when-compile=. The effect of this is to perform all
of the package initialization during compilation so that when byte compiled, all of this time consuming
code is skipped. This can be done because the result of byte compiling =use-package= statements results
in the macro being fully expanded at which point =use-package= isn't actually required any longer.

Since the code is automatically compiled during runtime, if the configuration hasn't already been
previously compiled manually then all of the package initialization will still take place at startup.

#+BEGIN_SRC emacs-lisp :tangle yes
(if (bound-and-true-p *proxy-host*)
    (kwarks/set-proxy *proxy-host*))

(eval-when-compile
  (require 'package)

  (unless (assoc-default "melpa" package-archives)
    (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
    (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t))

  (package-initialize)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t))

(use-package quelpa-use-package
  :demand t
  :init (setq quelpa-update-melpa-p nil)
  :config (quelpa-use-package-activate-advice))
#+END_SRC

* Theme
** Theme helper functions
#+BEGIN_SRC emacs-lisp
(require 'color)

(defmacro kwarks/if-dark-theme (action else-action)
  `(if (eq (frame-parameter nil 'background-mode) 'dark)
       ,action
     ,else-action))

(defun kwarks/color-from-theme (lighter-percentage darker-percentage)
  (kwarks/if-dark-theme
   (color-lighten-name (face-background 'default) lighter-percentage)
   (color-darken-name (face-background 'default) darker-percentage)))
#+END_SRC

** Suppress GUI features

#+BEGIN_SRC emacs-lisp :tangle yes
(setq use-file-dialog nil)
(setq use-dialog-box nil)
(setq inhibit-startup-screen t)
(setq inhibit-startup-echo-area-message t)
#+END_SRC

** Turn off menu, toolbar and scrollbars

#+BEGIN_SRC emacs-lisp :tangle yes
(unless-osx
  (menu-bar-mode -1))
(tool-bar-mode -1)
(set-scroll-bar-mode nil)
#+END_SRC

** Visual bell
Flash modeline for visual bell

#+BEGIN_SRC emacs-lisp :tangle yes
(setq visible-bell nil
      ring-bell-function
      (lambda ()
        (let ((fg (face-foreground 'mode-line))
              (bg (face-background 'mode-line)))
          (set-face-background 'mode-line "#30363F")
          (set-face-foreground 'mode-line "#30363F")
          (run-with-idle-timer 0.1 nil `(lambda ()
                                          (set-face-background 'mode-line ,bg)
                                          (set-face-foreground 'mode-line ,fg))))))
#+END_SRC

** Highlight current line

Ignore line wrappings and highlight entire line for org headers

#+BEGIN_SRC emacs-lisp :tangle yes
(defun visual-line-range ()
  (save-excursion
    (cons
     (progn (vertical-motion 0) (point))
     (progn (vertical-motion 1) (point)))))

(setq hl-line-range-function 'visual-line-range)

(global-hl-line-mode 1)
#+END_SRC

** visual-line
#+BEGIN_SRC emacs-lisp
(setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
(global-visual-line-mode 1)
#+END_SRC

** Main theme
#+BEGIN_SRC emacs-lisp
(defmacro kwarks/with-make-frame (&rest body)
  `(if (daemonp)
       (add-hook 'after-make-frame-functions
                 (lambda (&rest args) (progn ,@body)) t)
     ,@body))

(defun kwarks/set-cursor-color ()
  (set-face-background 'cursor (kwarks/color-from-theme 100 100)))

(defun kwarks/set-hl-line-color ()
  (set-face-background 'hl-line (kwarks/color-from-theme 6 7)))

(defun kwarks/set-linum-color ()
  (set-face-foreground 'linum (kwarks/color-from-theme 20 20)))

(defun kwarks/set-region-color ()
  (set-face-background 'region (kwarks/color-from-theme 15 15)))

(defun kwarks/set-border-color ()
  (let ((color (kwarks/color-from-theme 5 10)))
    (set-face-attribute 'mode-line nil :overline color)
    (set-face-attribute 'mode-line-inactive nil :overline color)
    (set-face-attribute 'vertical-border nil :foreground color)))

(defun kwarks/set-border-color ()
  (let ((color (kwarks/color-from-theme 5 10)))
    (set-face-attribute 'mode-line nil :foreground "gray" :background nil :box nil :overline color)
    (set-face-attribute 'mode-line-inactive nil :background nil :box nil :foreground "gray" :overline color)
    (set-face-attribute 'vertical-border nil :background nil :foreground color)))

(defun kwarks/set-titlebar-style ()
  (set-frame-parameter nil 'ns-transparent-titlebar t)
  (kwarks/if-dark-theme
   (set-frame-parameter nil 'ns-appearance 'dark)
   (set-frame-parameter nil 'ns-appearance nil)))

(defun kwarks/set-theme-colors (&rest args)
  (kwarks/set-cursor-color)
  (kwarks/set-hl-line-color)
  (kwarks/set-linum-color)
  (kwarks/set-region-color)
  (kwarks/set-border-color)
  (kwarks/set-titlebar-style)
  (set-frame-parameter nil 'alpha '(90 . 90)))

(defadvice load-theme (before theme-dont-propagate activate)
  (mapc #'disable-theme custom-enabled-themes))

(defadvice load-theme (after run-after-load-theme-hook activate)
  "Run `after-load-theme-hook'."
  (kwarks/set-theme-colors))

(defun kwarks/set-theme-faces ()
  (custom-set-faces
   `(cursor                   ((t (:background ,(kwarks/color-from-theme 100 100)))))
   '(font-lock-comment-face   ((t (:slant italic :background nil))))
   '(trailing-whitespace      ((t (:foreground "gray"     :background "gray"))))
   '(fringe                   ((t (:foreground "SkyBlue4" :background nil))))))

(defun kwarks/setup-frame (&rest args)
  "Apply titlebar theme for new frames"
  (kwarks/set-titlebar-style)
  (kwarks/set-theme-colors)
  (kwarks/set-theme-faces)
  (set-frame-position nil 350 100)
  (set-frame-size nil 110 40)
  (set-frame-parameter nil 'fullscreen nil))

(kwarks/with-make-frame (kwarks/setup-frame))
;;(add-hook 'after-make-frame-functions 'kwarks/setup-frame t)

(use-package doom-themes
  :init
  (setq doom-one-brighter-comments t)
  (load-theme 'doom-one t))

#+END_SRC

** Spaceline
#+BEGIN_SRC emacs-lisp
(setq ns-use-srgb-colorspace nil) ; without it spaceline looks ugly...

(kwarks/with-make-frame
 (custom-set-faces
  `(powerline-active1        ((t (:foreground "SkyBlue1" :background nil))))
  `(powerline-active2        ((t (:foreground "white"    :background nil))))
  `(powerline-inactive1      ((t (:foreground "SkyBlue4" :background nil))))
  `(powerline-inactive2      ((t (:foreground "SkyBlue4" :background nil))))))

(use-package spaceline
  :init
  (require 'spaceline-config)
  (setq powerline-default-separator 'alternate)
  (setq spaceline-highlight-face-func 'spaceline-highlight-face-modified)
  (spaceline-emacs-theme)
  (spaceline-toggle-minor-modes-off)
  (spaceline-toggle-hud-off)
  (remove-hook 'focus-out-hook 'powerline-unset-selected-window))

(setq display-time-day-and-date t)
(setq display-time-string-forms
      '((propertize (format-time-string "%a %b %d, %R" now) 'weight 'normal)))
(display-time-mode t)


#+END_SRC
** org-mode visuals
#+BEGIN_SRC emacs-lisp
(require 'org)
(add-to-list 'org-emphasis-alist
             '("*" (:foreground "red")))

(kwarks/with-make-frame
 (custom-set-faces
  '(org-level-1             ((t (:box nil :height 130 :foreground "#51afef" :background nil))))
  '(org-level-2             ((t (:foreground "#c678dd" :background nil))))
  '(org-level-3             ((t (:foreground "#a9a1e1" :background nil))))
  '(org-block               ((t (:background nil))))
  '(org-block-begin-line    ((t (:background nil :slant italic))))
  '(org-block-end-line      ((t (:background nil :slant italic))))
  '(font-lock-comment-face  ((t (:background nil))))
  '(org-ellipsis            ((t (:background nil :strike-through nil))))
  '(org-done                ((t (:strike-through t))))
  '(org-headline-done       ((t (:strike-through t))))
  '(org-agenda-done         ((t (:strike-through t))))
  '(org-agenda-date         ((t (:foreground "gray" :height 130 :weight normal))))
  '(org-agenda-date-weekend ((t (:height 130 :weight normal))))
  '(org-agenda-structure    ((t (:height 130 :weight normal))))
  '(org-agenda-date-today   ((t (:foreground "#a9a1e1" :weight normal :slant italic :height 130))))))

;;org-agenda-date-today
;;  `(trailing-whitespace      ((t (:foreground "gray"     :background "gray"))))
(custom-set-variables
 '(org-pretty-entities t)
 '(org-hide-emphasis-markers t))

#+END_SRC
* Packages
** crux
Set C-a to move to the first non-whitespace character on a line, and then to toggle between that and the beginning of the line.

#+BEGIN_SRC emacs-lisp
(use-package crux
    :ensure t
    :bind (("C-a" . crux-move-beginning-of-line)))
#+END_SRC
** hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra)
#+END_SRC

** diminish
This package implements hiding or abbreviation of the mode line displays (lighters) of minor-modes.

#+BEGIN_SRC emacs-lisp
(use-package diminish)
#+END_SRC
** saveplace

#+BEGIN_SRC emacs-lisp
(require 'saveplace)
(setq save-place-file (expand-file-name "places" user-emacs-directory))

(if (fboundp #'save-place-mode)
    (save-place-mode 1)
  (setq-default save-place t))
#+END_SRC

** undo-tree
Use "C-/" or "C-z" for undo, and "C-?" or "C-Z" for redo, "C-x u" to display a tree view of undo history.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :config  
  (let ((undo-dir (expand-file-name "undo" user-emacs-directory)))
    (unless (file-directory-p undo-dir)
      (make-directory undo-dir))
    (setq undo-tree-history-directory-alist `(("." . ,undo-dir)))
    (setq undo-tree-auto-save-history t))

  (defalias 'redo 'undo-tree-redo)
  (global-set-key (kbd "C-z") 'undo)
  (global-set-key (kbd "C-S-z") 'redo)
  
  (global-undo-tree-mode 1))
#+END_SRC
** session
#+BEGIN_SRC emacs-lisp
(use-package session)

(setq session-save-file (expand-file-name ".session" user-emacs-directory))
(setq session-name-disable-regexp "\\(?:\\`'/tmp\\|\\.git/[A-Z_]+\\'\\)")
(add-hook 'after-init-hook 'session-initialize)

;; automatically reveal folded sections in org file
(add-hook 'session-after-jump-to-last-change-hook
	  (lambda ()
	    (when (and (or (memq major-mode  '(org-mode outline-mode))
			   (and (boundp 'outline-minor-mode)
				outline-minor-mode))
		       (outline-invisible-p))
	      (if (eq major-mode 'org-mode)
		  (org-reveal)
		(show-subtree)))))

(session-jump-to-last-change)

#+END_SRC
** ido-completing-read+
This package replaces stock emacs completion with ido completion wherever it is possible.

#+BEGIN_SRC emacs-lisp
(use-package ido-completing-read+
  :config
  (ido-ubiquitous-mode t))
#+END_SRC
** exec-path-from-shell
Ensure environment variables inside Emacs look the same as in the user's shell.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :config
  (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO" "LANG" "LC_CTYPE"))
    (add-to-list 'exec-path-from-shell-variables var)))

(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))
#+END_SRC

** auto-dim-other-buffers
The auto-dim-other-buffers-mode is a global minor mode which makes non-current buffer less prominent making it more apparent which window has a focus.

#+BEGIN_SRC emacs-lisp
(defun kwarks/set-auto-dim-other-buffers-background (&rest args)
  (set-face-background 'auto-dim-other-buffers-face (kwarks/color-from-theme 3 3)))

(use-package auto-dim-other-buffers
  :config
  (setq auto-dim-other-buffers-dim-on-focus-out nil)
  (kwarks/set-auto-dim-other-buffers-background)
  :init
  (auto-dim-other-buffers-mode t))

(advice-add 'load-theme :after 'kwarks/set-auto-dim-other-buffers-background)
#+END_SRC

** focus-mode
Focus provides focus-mode that dims the text of surrounding sections.

#+BEGIN_SRC emacs-lisp
(use-package focus)
#+END_SRC
** smex
Smex is a M-x enhancement for Emacs. Built on top of Ido, it provides a convenient interface to recently and most frequently used commands. And to all the other commands, too.

#+BEGIN_SRC emacs-lisp
(use-package smex
  :init
  ;; Change path for ~/.smex-items
  (setq smex-save-file (expand-file-name ".smex-items" user-emacs-directory))
  (smex-initialize))
  ;; :config
  ;; (global-set-key (kbd "M-x") 'smex)
  ;; (global-set-key (kbd "M-X") 'smex-major-mode-commands)
  ;; (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command))
#+END_SRC
** helm
Most of the configuration is taken from https://github.com/compunaut/helm-ido-like-guide
Also check https://gist.github.com/izahn/00b7b930db646e15bae3d3741f603af5

*** Initial setup
#+BEGIN_SRC emacs-lisp
(defun kwarks/helm-top-sh (orig-fn &rest args)
  "Run kill shell command with signal SIG on PIDS for `helm-top'."
  (let ((default-directory "/sudo::")
        (sig (car args))
        (pids (cadr args)))
    (message "kill -s %s %s exited with status %s"
             sig (mapconcat 'identity pids " ")
             (apply (lambda (pid)
                      (shell-command (format "kill -s %s %s" sig pid)))
                    pids))))

(use-package helm
  :config
  ;; override helm-top behaviour to use sudo for killing processes
  (advice-add 'helm-top-sh :around #'kwarks/helm-top-sh))

(require 'helm)

(use-package helm-swoop)
(use-package helm-flx)
(use-package helm-fuzzier)
(use-package helm-smex)
(use-package helm-themes)

(defun helm-ido-like-activate-helm-modes ()
  (require 'helm-config)
  (helm-mode 1)
  (helm-flx-mode 1)
  (helm-fuzzier-mode 1))

(global-set-key [remap execute-extended-command] 'helm-M-x)
(global-set-key (kbd "M-X") #'helm-smex-major-mode-commands)
(global-set-key (kbd "C-x b") 'helm-buffers-list)
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(global-set-key (kbd "C-c f") 'helm-recentf)
(global-set-key (kbd "C-x C-f") 'helm-find-files)
(global-set-key (kbd "C-x r b") 'helm-filtered-bookmarks)
(global-set-key (kbd "C-h r") 'helm-info-emacs)
(global-set-key (kbd "C-h i") 'helm-info-at-point)
(global-set-key (kbd "C-h C-f") 'helm-apropos)
(global-set-key (kbd "C-c i") 'helm-imenu-in-all-buffers)
#+END_SRC

*** Appearance
Change candidates face

#+BEGIN_SRC emacs-lisp
;; todo: get face from theme
(set-face-attribute 'helm-candidate-number nil 
                    :foreground "#51afef"
                    :background nil)
#+END_SRC

The following snippet will configure helm to always pop up at the bottom.

#+BEGIN_SRC emacs-lisp
(defun helm-ido-like-load-ido-like-bottom-buffer ()
  ;; popup helm-buffer at the bottom
  (setq helm-split-window-in-side-p t)
  (add-to-list 'display-buffer-alist
               '("\\`\\*helm.*\\*\\'"
                 (display-buffer-in-side-window)
                 (window-height . 0.4)))
  (add-to-list 'display-buffer-alist
               '("\\`\\*helm help\\*\\'"
                 (display-buffer-pop-up-window)))

  ;; same for helm swoop
  (setq helm-swoop-split-with-multiple-windows nil
        helm-swoop-split-direction 'split-window-vertically
        helm-swoop-split-window-function 'helm-default-display-buffer)
  ;; dont display the header line
  (setq helm-display-header-line nil)
  ;; input in header line
  (setq helm-echo-input-in-header-line t)
  (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe))
#+END_SRC

The modelines above the helm buffer are not useful and hiding them will make helm look nicer in my opinion, too. You can do that with the following code.

#+BEGIN_SRC emacs-lisp
(defvar helm-ido-like-bottom-buffers nil
  "List of bottom buffers before helm session started.
Its element is a pair of `buffer-name' and `mode-line-format'.")

(defun helm-ido-like-bottom-buffers-init ()
  (setq-local mode-line-format (default-value 'mode-line-format))
  (setq helm-ido-like-bottom-buffers
        (cl-loop for w in (window-list)
                 when (window-at-side-p w 'bottom)
                 collect (with-current-buffer (window-buffer w)
                           (cons (buffer-name) mode-line-format)))))

(defun helm-ido-like-bottom-buffers-hide-mode-line ()
  (mapc (lambda (elt)
          (with-current-buffer (car elt)
            (setq-local mode-line-format nil)))
        helm-ido-like-bottom-buffers))

(defun helm-ido-like-bottom-buffers-show-mode-line ()
  (when helm-ido-like-bottom-buffers
    (mapc (lambda (elt)
            (with-current-buffer (car elt)
              (setq-local mode-line-format (cdr elt))))
          helm-ido-like-bottom-buffers)
    (setq helm-ido-like-bottom-buffers nil)))

(defun helm-ido-like-helm-keyboard-quit-advice (orig-func &rest args)
  (helm-ido-like-bottom-buffers-show-mode-line)
  (apply orig-func args))

(defun helm-ido-like-hide-modelines ()
  ;; hide The Modelines while Helm is active
  (add-hook 'helm-before-initialize-hook #'helm-ido-like-bottom-buffers-init)
  (add-hook 'helm-after-initialize-hook #'helm-ido-like-bottom-buffers-hide-mode-line)
  (add-hook 'helm-exit-minibuffer-hook #'helm-ido-like-bottom-buffers-show-mode-line)
  (add-hook 'helm-cleanup-hook #'helm-ido-like-bottom-buffers-show-mode-line)
  (advice-add 'helm-keyboard-quit :around #'helm-ido-like-helm-keyboard-quit-advice))
#+END_SRC

If you like you can hide helms own mode-line as well:
#+BEGIN_SRC emacs-lisp
(defun helm-ido-like-hide-helm-modeline-1 ()
  "Hide mode line in `helm-buffer'."
  (with-helm-buffer
    (setq-local mode-line-format nil)))

(defun helm-ido-like-hide-helm-modeline ()
  (fset 'helm-display-mode-line #'ignore)
  (add-hook 'helm-after-initialize-hook 'helm-ido-like-hide-helm-modeline-1))
#+END_SRC

The header lines for the sources are only useful if there are more then a single source. The following snippet will hide the header line if there is only one.
#+BEGIN_SRC emacs-lisp
(defvar helm-ido-like-source-header-default-background nil)
(defvar helm-ido-like-source-header-default-foreground nil)
(defvar helm-ido-like-source-header-default-box nil)

(defun helm-ido-like-toggle-header-line ()
  ;; Only Show Source Headers If More Than One
  (if (> (length helm-sources) 1)
      (set-face-attribute 'helm-source-header
                          nil
                          :foreground helm-ido-like-source-header-default-foreground
                          :background helm-ido-like-source-header-default-background
                          :box helm-ido-like-source-header-default-box
                          :height 1.0)
    (set-face-attribute 'helm-source-header
                        nil
                        :foreground (face-attribute 'helm-selection :background)
                        :background (face-attribute 'helm-selection :background)
                        :box nil
                        :height 0.1)))

(defun helm-ido-like-header-lines-maybe ()
  (setq helm-ido-like-source-header-default-background (face-attribute 'helm-source-header :background))
  (setq helm-ido-like-source-header-default-foreground (face-attribute 'helm-source-header :foreground))
  (setq helm-ido-like-source-header-default-box (face-attribute 'helm-source-header :box))
  (add-hook 'helm-before-initialize-hook 'helm-ido-like-toggle-header-line))
#+END_SRC

If you like you can change the background color of the helm-buffer.
#+BEGIN_SRC emacs-lisp
(defvar helm-ido-like-bg-color (face-attribute 'default :background))

(defun helm-ido-like-setup-bg-color-1 ()
  (with-helm-buffer
    (make-local-variable 'face-remapping-alist)
    (add-to-list 'face-remapping-alist `(default (:background ,helm-ido-like-bg-color)))))

(defun helm-ido-like-setup-bg-color ()
  (add-hook 'helm-after-initialize-hook 'helm-ido-like-setup-bg-color-1))
#+END_SRC

*** File Navigation
The following snippet will reconfigure the behaviour of keys in helm file navigation buffers.

Backspace goes to the upper folder if you are not inside a filename, and Return will select a file or navigate into the directory if it is one.

#+BEGIN_SRC emacs-lisp
(defun helm-ido-like-find-files-up-one-level-maybe ()
  (interactive)
  (if (looking-back "/" 1)
      (call-interactively 'helm-find-files-up-one-level)
    (delete-char -1)))

(defun helm-ido-like-find-files-navigate-forward (orig-fun &rest args)
  "Adjust how helm-execute-persistent actions behaves, depending on context."
  (let ((sel (helm-get-selection)))
    (if (file-directory-p sel)
        ;; the current dir needs to work to
        ;; be able to select directories if needed
        (cond ((and (stringp sel)
                    (string-match "\\.\\'" (helm-get-selection)))
               (helm-maybe-exit-minibuffer))
              (t
               (apply orig-fun args)))
      (helm-maybe-exit-minibuffer))))

(defun helm-ido-like-load-file-nav ()
  (advice-add 'helm-execute-persistent-action :around #'helm-ido-like-find-files-navigate-forward)
    ;; <return> is not bound in helm-map by default
  (define-key helm-map (kbd "<return>") 'helm-maybe-exit-minibuffer)
  (with-eval-after-load 'helm-files
    (define-key helm-read-file-map (kbd "<backspace>") 'helm-ido-like-find-files-up-one-level-maybe)
    (define-key helm-read-file-map (kbd "DEL") 'helm-ido-like-find-files-up-one-level-maybe)
    (define-key helm-find-files-map (kbd "<backspace>") 'helm-ido-like-find-files-up-one-level-maybe)
    (define-key helm-find-files-map (kbd "DEL") 'helm-ido-like-find-files-up-one-level-maybe)

    (define-key helm-find-files-map (kbd "<return>") 'helm-execute-persistent-action)
    (define-key helm-read-file-map (kbd "<return>") 'helm-execute-persistent-action)
    (define-key helm-find-files-map (kbd "RET") 'helm-execute-persistent-action)
    (define-key helm-read-file-map (kbd "RET") 'helm-execute-persistent-action)))
#+END_SRC

And this snippet will remove the dots in helm file navigation

#+BEGIN_SRC emacs-lisp
(defvar helm-ido-like-no-dots-whitelist
  '("*Helm file completions*")
  "List of helm buffers in which to show dot directories.")

 (defun helm-ido-like-no-dots-display-file-p (file)
  ;; in a whitelisted buffer display all but the relative path to parent dir
  (or (and (member helm-buffer helm-ido-like-no-dots-whitelist)
           (not (string-match "\\(?:/\\|\\`\\)\\.\\{2\\}\\'" file)))
      ;; in all other buffers display all files but the two relative ones
      (not (string-match "\\(?:/\\|\\`\\)\\.\\{1,2\\}\\'" file))))

(defun helm-ido-like-no-dots-auto-add (&rest args)
  "Auto add buffers which want to read directory names to the whitelist."
  (if (eq (car (last args)) 'file-directory-p)
      (add-to-list 'helm-ido-like-no-dots-whitelist
                   (format "*helm-mode-%s*"
                           (helm-symbol-name
                            (or (helm-this-command) this-command))))))

(defun helm-ido-like-no-dots ()
  (require 'cl-lib)
  (advice-add 'helm-ff-filter-candidate-one-by-one
              :before-while 'helm-ido-like-no-dots-display-file-p)
  (advice-add  'helm--generic-read-file-name :before 'helm-ido-like-no-dots-auto-add))
#+END_SRC

*** Improve Flx support
And you can increase flx speed (I have not benchmarked it myself) by adjusting the garbage collection setting. In addition to that the following snippet advices the helm source function to enable the flx fuzzy match in most sources but file completions(you still have fuzzy matching from helm) and async sources.

#+BEGIN_SRC emacs-lisp
(defvar helm-ido-like-user-gc-setting nil)

(defun helm-ido-like-higher-gc ()
  (setq helm-ido-like-user-gc-setting gc-cons-threshold)
  (setq gc-cons-threshold most-positive-fixnum))

(defun helm-ido-like-lower-gc ()
  (setq gc-cons-threshold helm-ido-like-user-gc-setting))

(defun helm-ido-like-helm-make-source (f &rest args)
  (let ((source-type (cadr args)))
    (unless (or (memq source-type '(helm-source-async helm-source-ffiles))
                (eq (plist-get args :filtered-candidate-transformer)
                    'helm-ff-sort-candidates)
                (eq (plist-get args :persistent-action)
                    'helm-find-files-persistent-action))
      (nconc args '(:fuzzy-match t))))
  (apply f args))

(defun helm-ido-like-load-fuzzy-enhancements ()
  (add-hook 'minibuffer-setup-hook #'helm-ido-like-higher-gc)
  (add-hook 'minibuffer-exit-hook #'helm-ido-like-lower-gc)
  (advice-add 'helm-make-source :around 'helm-ido-like-helm-make-source))
#+END_SRC

With recent helm version there is a problem for file navigation, when helm-fuzzier is activated. Because of that it’s better to deactivate it for file completions. 

*TODO: check if it's still a case*

#+BEGIN_SRC emacs-lisp
(defun helm-ido-like-fuzzier-deactivate (&rest _)
  (helm-fuzzier-mode -1))

(defun helm-ido-like-fuzzier-activate (&rest _)
  (unless helm-fuzzier-mode
    (helm-fuzzier-mode 1)))

(defun helm-ido-like-fix-fuzzy-files ()
  (add-hook 'helm-find-files-before-init-hook #'helm-ido-like-fuzzier-deactivate)
  (advice-add 'helm--generic-read-file-name :before #'helm-ido-like-fuzzier-deactivate)
  (add-hook 'helm-exit-minibuffer-hook #'helm-ido-like-fuzzier-activate)
  (add-hook 'helm-cleanup-hook #'helm-ido-like-fuzzier-activate)
  (advice-add 'helm-keyboard-quit :before #'helm-ido-like-fuzzier-activate))
#+END_SRC

*** Last Steps
#+BEGIN_SRC emacs-lisp
(defun helm-ido-like ()
  "Configure and activate `helm', `helm-fuzzier' and `helm-flx'."
  (interactive)
  (helm-ido-like-activate-helm-modes)
  (helm-ido-like-load-ido-like-bottom-buffer)
  (helm-ido-like-hide-modelines)
;;  (helm-ido-like-hide-helm-modeline)
  (helm-ido-like-header-lines-maybe)
  (helm-ido-like-setup-bg-color)
  (helm-ido-like-load-file-nav)
  (helm-ido-like-no-dots)
  (helm-ido-like-load-fuzzy-enhancements)
  (helm-ido-like-fix-fuzzy-files))

(helm-ido-like)
#+END_SRC
** company
Company stands for “complete anything” and is a modular in-buffer completion mechanism.

#+BEGIN_SRC emacs-lisp
(use-package company
  :config
  (define-key company-mode-map (kbd "M-/") 'company-complete)
  (define-key company-active-map (kbd "M-/") 'company-select-next)
  (global-set-key (kbd "M-C-/") 'company-complete)
  :init
  (global-company-mode)
  (diminish 'company-mode "CMP"))

(use-package company-quickhelp
  :config
  (define-key company-active-map (kbd "C-c h") #'company-quickhelp-manual-begin)
  :init
  (company-quickhelp-mode))
#+END_SRC
** paradox
Project for modernizing Emacs' Package Menu. With improved appearance, mode-line information. Github integration, customizability, asynchronous upgrading, and more.

#+BEGIN_SRC emacs-lisp
(use-package paradox
  :config
  (setq paradox-github-token t))
#+END_SRC

** switch-window
Make "C-x o" prompt for a target window when there are more than 2

#+BEGIN_SRC emacs-lisp
(use-package switch-window)

(setq-default switch-window-shortcut-style 'alphabet)
(setq-default switch-window-timeout nil)
(global-set-key (kbd "C-x o") 'switch-window)
#+END_SRC
** guide-key
#+BEGIN_SRC emacs-lisp
  (use-package guide-key
    :config
    (setq guide-key/guide-key-sequence '("C-x" "C-c" "C-x 4" "C-x 5" "C-c ;" "C-c ; f" "C-c ' f" "C-x n" "C-x C-r" "C-x r" "M-s" "C-h"))
    :init
    (guide-key-mode 1)
    (diminish 'guide-key-mode))
#+END_SRC
** dired-single
#+BEGIN_SRC emacs-lisp
(use-package dired-single)

(defun kwarks/dired-init ()
  (define-key dired-mode-map [return] 'dired-single-buffer)
  (define-key dired-mode-map [mouse-1] 'dired-single-buffer-mouse)
  (define-key dired-mode-map "^"
    (function
     (lambda nil (interactive) (dired-single-buffer "..")))))

(if (boundp 'dired-mode-map)
    (kwarks/dired-init)
  (add-hook 'dired-load-hook 'kwarks/dired-init))
#+END_SRC
** page-break-lines
This Emacs library provides a global mode which displays ugly form feed characters as tidy horizontal rules.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package page-break-lines
  :after (diminish)
  :config
  (push 'browse-kill-ring-mode page-break-lines-modes)
  (push 'special-mode page-break-lines-modes)
  (global-page-break-lines-mode)
  (diminish 'page-break-lines-mode))
#+END_SRC

** org
Include a newer version of org-mode than the one that is built in. 

#+BEGIN_SRC emacs-lisp
;;
(use-package org
  :ensure org-plus-contrib
  :pin org
  :defer t)
;; Ensure ELPA org is prioritized above built-in org.
(require 'cl)
(setq load-path (remove-if (lambda (x) (string-match-p "org$" x)) load-path))

(use-package ox-gfm)

;; (use-package org
;;   :quelpa (org
;; 	       :url "https://code.orgmode.org/bzg/org-mode.git"
;; 	       :fetcher git
;; 	       :files ("lisp/*.el" "contrib/lisp/*.el" "doc/dir" "doc/*.texi")
;; 	       :upgrade nil)
;;   :config
;;   (require 'ox)
;;   (require 'ox-md)
;;   (require 'ox-html)
;;   (require 'ox-gfm)
;; ;;  (require 'org-tempo)
;;   :init
;;   (setq org-export-with-toc nil))
;;  :init (require 'org-tempo))

;; Display time grid for today
;; (setq org-agenda-time-grid
;;       (quote
;;        ((daily today remove-match)
;; 	(900 1000 1100 1200 1300 1400 1500 1600)
;;         "......" "----------------")))
#+END_SRC

*** basic settings
#+BEGIN_SRC emacs-lisp
(require 'org)
;; Create empty diary file if doesn't exists
(unless (file-exists-p diary-file)
  (write-region "" "" diary-file))

;; Show entries for 3 days
(setq diary-number-of-entries 3)
(setq calendar-week-start-day 1)

;; Highlight diary entries in calendar
(setq calendar-mark-diary-entries-flag t)

;; Disable sub-superscripts
(setq org-use-sub-superscripts '{})

(setq org-src-fontify-natively t
      org-src-window-setup 'current-window
      org-src-strip-leading-and-trailing-blank-lines t
      org-src-preserve-indentation t
      org-src-tab-acts-natively t)

(setq org-todo-keywords
      (quote ((sequence "TODO(t)" "ACTIVE(a)" "|" "DONE(d!/!)")
              (sequence "PROJECT(p)" "|" "DONE(d!/!)" "CANCELLED(c@/!)")
              (sequence "WAITING(w@/!)" "DELEGATED(e!)" "HOLD(h)" "|" "CANCELLED(c@/!)")))
      org-todo-repeat-to-state "ACTIVE")

(setq org-todo-keyword-faces
      (quote (("ACTIVE" :inherit warning)
              ("PROJECT" :inherit font-lock-string-face))))
#+END_SRC
*** org-crypt
#+BEGIN_SRC emacs-lisp
;; Encrypted entries
(require 'org-crypt)
(org-crypt-use-before-save-magic)

;; org entries with :crypt: tag will be encrypted automatically
;; use C-c C-c to add tag
;; use M-x org-decrypt-entry to decrypt
(setq org-tags-exclude-from-inheritance (quote ("crypt")))

;; GPG key to use for encryption
;; Either the Key ID or set to nil to use symmetric encryption.
;; use gpg --list-keys to find key id
(setq org-crypt-key "0645F0FB333B0EAA60279838995D889E67758C18")
#+END_SRC
*** org-agenda
see https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html

#+BEGIN_SRC emacs-lisp
(setq org-agenda-block-separator 8211 ; nicer separators
      org-agenda-compact-blocks nil)

(setq org-todo-dir (expand-file-name "org-todo" user-emacs-directory))
(unless (file-directory-p org-todo-dir)
  (make-directory org-todo-dir t))

(setq org-agenda-files (file-expand-wildcards (concat org-todo-dir "/*.org")))
(setq org-tag-alist '(("PROJECT" . ?p)))

(defun air-org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.

PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)
        subtree-end
      nil)))

(defun zin/org-agenda-skip-tag (tag &optional others)
  "Skip all entries that correspond to TAG.

If OTHERS is true, skip all entries that do not correspond to TAG."
  (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
        (current-headline (or (and (org-at-heading-p)
                                   (point))
                              (save-excursion (org-back-to-heading)))))
    (if others
        (if (not (member tag (org-get-tags-at current-headline)))
            next-headline
          nil)
      (if (member tag (org-get-tags-at current-headline))
          next-headline
        nil))))

(setq org-agenda-custom-commands
      '(("c" "Simple agenda view"
         ((tags "PROJECT"
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "Projects:")))
          (tags "PRIORITY=\"A\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "High-priority unfinished tasks:")))
          (agenda "")
          (alltodo ""
                   ((org-agenda-skip-function
                     '(or (air-org-skip-subtree-if-priority ?A)
                          (zin/org-agenda-skip-tag "PROJECT")
                          (org-agenda-skip-if nil '(scheduled deadline))))))))))

(defun display-agenda (&optional arg)
  "Display up-to-date week agenda."
  (interactive)
  (org-agenda arg "c")
  (org-agenda-redo)
  (toggle-truncate-lines 1))
#+END_SRC
** toc-org
toc-org helps to have an up-to-date table of contents in org files.

#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :after org
  :init (add-hook 'org-mode-hook #'toc-org-enable))
#+END_SRC

** alert
#+BEGIN_SRC emacs-lisp
(use-package alert
  :commands (alert)
  :init
  (when-osx
    (setq alert-default-style 'osx-notifier)))
#+END_SRC
** org-passwords
#+BEGIN_SRC emacs-lisp

(use-package org-passwords
  :quelpa (org-passwords
           :url "https://bitbucket.org/alfaromurillo/org-passwords.el.git"
           :fetcher git))

(eval-after-load "org-passwords"
  '(progn
     (define-key org-passwords-mode-map
       (kbd "C-c C-p u")
       'org-passwords-copy-username)
     (define-key org-passwords-mode-map
       (kbd "C-c C-p p")
       'org-passwords-copy-password)
     (define-key org-passwords-mode-map
       (kbd "C-c C-p o")
       'org-passwords-open-url)))
#+END_SRC
** org-wiki
Org-wiki is a org-mode extension that provides tools to manage and build personal wiki or desktop wiki where each wiki page is a org-mode file.

#+BEGIN_SRC emacs-lisp
(use-package org-wiki
  :demand t
  :quelpa (org-wiki
           :repo "caiorss/org-wiki"
           :fetcher github))

(setq org-wiki-location (expand-file-name "wiki" user-emacs-directory))
(unless (file-directory-p org-wiki-location)
  (make-directory org-wiki-location t))
#+END_SRC

** org-pretty-table
#+BEGIN_SRC emacs-lisp :tangle no
This package makes org tables use unicode symbols for drawing.
Currently it is very inefficient...

(use-package org-pretty-table
  :quelpa (org-pretty-table
	   :url "https://github.com/Fuco1/org-pretty-table.git"
	   :fetcher git
	   :files ("*.el")
	   :upgrade nil))
#+END_SRC
** helm-dash
Support for the http://kapeli.com/dash documentation browser. See https://github.com/areina/helm-dash

#+BEGIN_SRC emacs-lisp
(setq helm-dash-docsets-path (expand-file-name ".docsets" user-emacs-directory))

(unless (file-exists-p helm-dash-docsets-path)
  (make-directory helm-dash-docsets-path))

(defun helm-dash--use-docset (name docset)
  "Install DOCSET if it's not installed yet."
  (unless (member name (helm-dash-installed-docsets))
    (helm-dash-install-docset docset)))

(use-package helm-dash
  :config
  (helm-dash--use-docset "Common Lisp" "Common_Lisp")
  (add-hook 'lisp-mode-hook (lambda ()
                              (setq-local helm-dash-docsets '("Common Lisp"))))

  (helm-dash--use-docset "Emacs Lisp" "Emacs_Lisp")
  (add-hook 'emacs-lisp-mode-hook (lambda ()
                                    (setq-local helm-dash-docsets '("Emacs Lisp")))))

(if (featurep 'xwidget-internal)
  (setq helm-dash-browser-func 'xwidget-webkit-browse-url)
  (setq helm-dash-browser-func 'eww))

(global-set-key (kbd "C-c h") 'helm-dash-at-point)
#+END_SRC
** transpose-frame
Transpose windows arrangement in a frame.

#+BEGIN_SRC emacs-lisp
(use-package transpose-frame)
#+END_SRC

** reverse-im
Creates translation mappings for input-methods other than default english one, so all keybindings are usable while non-default system layout is active.

#+BEGIN_SRC emacs-lisp
(use-package reverse-im
  :demand t
  :config
  (add-to-list 'reverse-im-modifiers 'super)
  (reverse-im-activate "russian-computer"))
#+END_SRC

** osx dictionary

#+BEGIN_SRC emacs-lisp
(when-osx
  (use-package osx-dictionary)
  (global-set-key (kbd "C-c d") 'osx-dictionary-search-word-at-point))
#+END_SRC
** alert
#+BEGIN_SRC emacs-lisp
(use-package alert
  :commands (alert)
  :init
  (when-osx
    (setq alert-default-style 'osx-notifier)))
#+END_SRC

** nov.el - ePub reader
#+BEGIN_SRC emacs-lisp
(use-package nov
  :config
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+END_SRC

** weather
#+BEGIN_SRC emacs-lisp
(use-package wttrin
  :init
  (setq wttrin-default-cities '("Toronto"))
  (setq wttrin-default-accept-language '("Accept-Language" . "en-US")))

(defun weather ()
  "Show weather with default city and metric units"
  (interactive)
  (require 'wttrin)

  (let* ((city (car wttrin-default-cities))
         (weather-buffer (format "*Weather - %s*" city)))
    (if (buffer-live-p (get-buffer weather-buffer))
        (kill-buffer weather-buffer))
    (wttrin-query (format "%s?m" city))
    (rename-buffer weather-buffer)
    (toggle-truncate-lines 1)))
#+END_SRC

** fancy-battery
Show battery level in mode line
#+BEGIN_SRC emacs-lisp
(require 'battery)

(defun has-battery ()
  (if battery-status-function
      (let ((b-status (cdr (assoc '66 (funcall battery-status-function)))))
	(not (string= b-status "N/A")))))

(use-package fancy-battery
  :if (has-battery)
  :config
  (setq fancy-battery-show-percentage t)
  :init
  (fancy-battery-mode))
#+END_SRC

** horoscope
Just for fun.

#+BEGIN_SRC emacs-lisp
(use-package horoscope)
#+END_SRC
** eww
Disable eww images and switch to readability mode by default.

#+BEGIN_SRC emacs-lisp
(defhydra kwarks/eww-hydra (:color blue :hint nil)
  "
_&_ view in external browser
list _B_ookmarks
add _b_ookmark
_g_: reload page
_R_eadability mode
_f_ocus mode
back ur_l_
_n_ext url
_p_revious url
_v_iew source
"
  ("&" eww-browse-with-external-browser)
  ("B" eww-list-bookmarks)
  ("b" eww-add-bookmark)
  ("g" eww-reload)
  ("R" eww-readable)
  ("f" focus-mode)
  ("i" endless/toggle-image-display)
  ("l" eww-back-url)
  ("n" eww-next-url)
  ("p" eww-previous-url)
  ("v" eww-view-source))

(defun kwarks/eww-actions ()
  (interactive)
  (kwarks/eww-hydra/body))

(defun kwarks/around-eww-render (eww-render-fn &rest args)
  (let ((shr-inhibit-images t))
    (apply eww-render-fn args)))

(defun kwarks/after-eww-render ()
  "Turn on Readability mode and Focus mode"
  (unwind-protect
      (progn
	(eww-readable)
	(if (fboundp 'focus-mode) (focus-mode)))))

(advice-add 'eww-render :around #'kwarks/around-eww-render)
(add-hook 'eww-after-render-hook #'kwarks/after-eww-render)
#+END_SRC
* Programming
** magit
The magical git client. Let's load magit only when one of the several entry pont
functions we invoke regularly outside of magit is called.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :commands (magit-status magit-blame magit-log-buffer-file magit-log-all))
#+END_SRC

** git-gutter
Display file change indicators on a fringe and more

#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :init (global-git-gutter-mode)
  :config
  (defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
					:hint nil)
    "
Git gutter:
  _j_: next hunk        _s_tage hunk     _q_uit
  _k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
  ^ ^                   _p_opup hunk
  _h_: first hunk
  _l_: last hunk        set start _R_evision
"
    ("j" git-gutter:next-hunk)
    ("k" git-gutter:previous-hunk)
    ("h" (progn (goto-char (point-min))
		(git-gutter:next-hunk 1)))
    ("l" (progn (goto-char (point-min))
		(git-gutter:previous-hunk 1)))
    ("s" git-gutter:stage-hunk)
    ("r" git-gutter:revert-hunk)
    ("p" git-gutter:popup-hunk)
    ("R" git-gutter:set-start-revision)
    ("q" nil :color blue)
    ("Q" (progn (git-gutter-mode -1)
		;; git-gutter-fringe doesn't seem to
		;; clear the markup right away
		(sit-for 0.1)
		(git-gutter:clear))
     :color blue))
  
  (defun git-gutter-actions ()
    (interactive)
    (hydra-git-gutter/body)))
#+END_SRC

** git-timemachine
#+BEGIN_SRC emacs-lisp
(use-package git-timemachine)
#+END_SRC

** ztree-diff
ztree-diff is a directory-diff tool for Emacs inspired by commercial tools like Beyond Compare or Araxis Merge. It supports showing the difference between two directories; calling Ediff for not matching files, copying between directories, deleting file/directories, hiding/showing equal files/directories.

#+BEGIN_SRC emacs-lisp
(use-package ztree)
#+END_SRC

** scratch
M-x scratch will create a scratch buffer for the current mode.

#+BEGIN_SRC emacs-lisp
(use-package scratch)
#+END_SRC

** projectile
Projectile is a quick and easy project management package that "just works". We're
going to install it and make sure it's loaded immediately.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :demand t
  :init
  (projectile-mode))
#+END_SRC

** lsp-mode
A Emacs Lisp library for implementing clients for servers using Microsoft's Language Server Protocol.

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode)
(use-package company-lsp
  :config
  (setq company-lsp-enable-snippet t
	company-lsp-cache-candidates t))
(use-package lsp-ui)
#+END_SRC
** lisp
*** electric-pair-mode
Electric Pair mode, a global minor mode, provides a way to easily insert matching delimiters. 

#+BEGIN_SRC emacs-lisp
(electric-pair-mode)
#+END_SRC
*** slime
#+BEGIN_SRC emacs-lisp
  (use-package slime
    :config
    (setq slime-protocol-version 'ignore)
    (setq slime-net-coding-system 'utf-8-unix)
    (setq slime-complete-symbol*-fancy t)
    (setq slime-complete-symbol-function 'slime-fuzzy-complete-symbol)
    (setq inferior-lisp-program "sbcl")
    
    (require 'slime)
    (slime-setup '(slime-fancy)))

  (add-to-list 'auto-mode-alist '("\\.cl\\'" . lisp-mode))
#+END_SRC
*** scheme
It should simply work:

M-x run-scheme
M-x scheme-mode
C-x C-e to run code

Chicken integration instructions:

#+BEGIN_SRC sh
brew install chicken
chicken-install -s symbol-utils apropos chicken-doc fmt slime
cd `csi -p '(chicken-home)'`
curl http://3e8.org/pub/chicken-doc/chicken-doc-repo.tgz | sudo tar zx
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(defun kwarks/init-scheme ()
  (require 'slime)
  (setq slime-csi-path "/usr/local/bin/csi")
  (add-to-list 'load-path "/usr/local/lib/chicken/8/")
  (autoload 'chicken-slime "chicken-slime" "SWANK backend for Chicken" t)
  (add-hook 'scheme-mode-hook (lambda () (slime-mode t))))

(if (file-exists-p "/usr/local/lib/chicken")
    (kwarks/init-scheme))
#+END_SRC
*** rainbow-delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :init
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

*** highlight-symbol
#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol)
#+END_SRC
*** paredit
#+BEGIN_SRC emacs-lisp
(use-package paredit)
#+END_SRC
*** aggressive-indent
#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :init
  (add-hook 'lisp-mode-hook 'aggressive-indent-mode)
  (add-hook 'emacs-lisp-mode-hook 'aggressive-indent-mode))
#+END_SRC
** java
To make javacomp work with sbt projects use /retrieveManaged := true/ option.
This will copy all managed dependencies to <build-root>/lib_managed/ and make it available for javacomp.

#+BEGIN_SRC emacs-lisp
(use-package lsp-javacomp
  :commands lsp-javacomp-enable
  :init
  (add-hook 'java-mode-hook
            (lambda ()
              ;; Load company-lsp before enabling lsp-javacomp, so that function
              ;; parameter snippet works.
              (require 'company-lsp)
              ; (lsp-javacomp-enable)
              ;; Use company-lsp as the company completion backend
              ; (set (make-variable-buffer-local 'company-backends) '(company-lsp))
              ;; Optional company-mode settings
              (set (make-variable-buffer-local 'company-idle-delay) 0.1)
              (set (make-variable-buffer-local 'company-minimum-prefix-length) 1)))
  ;; Optional, make sure JavaComp is installed. See below.
  :config
  (lsp-javacomp-install-server))
#+END_SRC
** scala
*** sbt
#+BEGIN_SRC emacs-lisp
(use-package sbt-mode
  :commands sbt-start sbt-command
  :config
  ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
  ;; allows using SPACE when in the minibuffer
  (substitute-key-definition
   'minibuffer-complete-word
   'self-insert-command
   minibuffer-local-completion-map))
#+END_SRC
*** scala-mode
#+BEGIN_SRC emacs-lisp
(use-package scala-mode
  :interpreter
  ("scala" . scala-mode))
#+END_SRC
** swift
#+BEGIN_SRC emacs-lisp
(use-package swift-mode)
#+END_SRC
** .net
#+BEGIN_SRC emacs-lisp

(defun kwarks/init-csharp-mode ()
  (setq indent-tabs-mode nil)
  (setq c-syntactic-indentation t)
  (c-set-style "ellemtel")
  (setq c-basic-offset 4)
  (setq truncate-lines t)
  (setq tab-width 4)
  (local-set-key (kbd "C-c C-c") 'recompile))

(use-package csharp-mode
  :config
  (add-hook 'csharp-mode-hook 'kwarks/init-csharp-mode))

(use-package dotnet
  :config
  (add-hook 'csharp-mode-hook 'dotnet-mode))

;; (use-package omnisharp
;;   :config
;;   (define-key omnisharp-mode-map (kbd "M-.") 'omnisharp-auto-complete))

(use-package omnisharp
  :bind (:map omnisharp-mode-map
	      ("M-." . omnisharp-auto-complete)))

;; (add-hook 'csharp-mode-hook (lambda ()
;; 			      (setq indent-tabs-mode nil)
;; 			      (setq c-syntactic-indentation t)
;; 			      (c-set-style "ellemtel")
;; 			      (setq c-basic-offset 4)
;; 			      (setq truncate-lines t)
;; 			      (setq tab-width 4)
;; 			      (local-set-key (kbd "C-c C-c") 'recompile))
;; 	  t)


#+END_SRC

** python
#+begin_src emacs-lisp
(setq python-shell-interpreter "/usr/local/bin/python3")
#+end_src
** immortal-scratch
#+BEGIN_SRC emacs-lisp
(use-package immortal-scratch)
#+END_SRC
** multiple-cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors)
#+END_SRC
** dumb-jump
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :bind (("M-g o" . dumb-jump-go-other-window)
         ("M-g j" . dumb-jump-go)
         ("M-g p" . dumb-jump-back)
         ("M-g x" . dumb-jump-go-prefer-external)
         ("M-g z" . dumb-jump-go-prefer-external-other-window))
  :config (setq dumb-jump-selector 'helm))
#+END_SRC
** indent-guide

#+BEGIN_SRC emacs-lisp
(use-package indent-guide
  :config
  (setq indent-guide-char "┊")
  (setq indent-guide-delay 0.1)
  :init
  (diminish 'indent-guide-mode))

;; (add-hook 'prog-mode-hook 'indent-guide-mode)
#+END_SRC

** sicp
Structure and Interpretation of Computer Programs ebook
#+BEGIN_SRC emacs-lisp
(use-package sicp)
#+END_SRC
** json
#+BEGIN_SRC emacs-lisp
(use-package json-mode)
#+END_SRC
** yaml
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode)
#+END_SRC

** http
*** know-your-http-well
HTTP encodings, headers, media types, methods, relations and status codes, all summarized and linking to their specification.

#+BEGIN_SRC emacs-lisp
(use-package know-your-http-well
  :after (helm)
  :init
  (require 'http-status-codes)
  (require 'http-headers)
  (require 'http-methods)
  (require 'media-types)
  (require 'http-relations)

  (defmacro helm-know-your-http-well (source selector-fn)
    `(helm :sources (helm-build-sync-source "helm-know-your-http-well"
		      :candidates ,source
		      :action (lambda (candidate)
				(message (funcall ,selector-fn candidate))))
	   :buffer "*helm-know-your-http-well*"))

  (defun kwarks/every-other (lst)
    "Return odd elements of the lst"
    (if (null lst) '()
      (cons (car lst) (kwarks/every-other (cddr lst)))))

  (defun helm-http-status-code ()
    "Look up the meaning of HTTP status codes"
    (interactive)
    (helm-know-your-http-well
     (mapcar (lambda (arg) ; combine http status with description
	       (cons (concat (car arg) " - " (caadr arg)) (cdr arg)))
	     (kwarks/every-other http-status))
     'cadar))

  (defun helm-http-header ()
    "Look up the meaning of HTTP headers"
    (interactive)
    (helm-know-your-http-well http-headers 'caar))
  
  (defun helm-http-method ()
    "Look up the meaning of HTTP methods"
    (interactive)
    (helm-know-your-http-well http-methods 'caar))
  
  (defun helm-media-type ()
    "Look up the template of a media-type"
    (interactive)
    (helm-know-your-http-well media-types 'caar))

  (defun helm-http-relation ()
    "Look up the meaning of HTTP relations"
    (interactive)
    (helm-know-your-http-well http-relations 'caar)))
#+END_SRC

*** Rest Client

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :config
  (add-to-list 'auto-mode-alist '("\\.rest$" . restclient-mode))
  (setq restclient-inhibit-cookies t))

;; An extension to restclient that provides org-babel support.
(use-package ob-restclient
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((restclient . t))))

;; Company-mode completion back-end for restclient-mode.
(use-package company-restclient
  :config
  (add-to-list 'company-backends 'company-restclient))
#+END_SRC

*** Http Repl

#+BEGIN_SRC emacs-lisp
(use-package httprepl)
#+END_SRC

* Post init
** Start server
#+BEGIN_SRC emacs-lisp
(unless-windows
 (require 'server)
 (unless (server-running-p)
   (server-start)))
#+END_SRC

** Garbage collection
Let's lower our GC thresholds back down to a sane level.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 16777216
      gc-cons-percentage 0.1)
#+END_SRC
